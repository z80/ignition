[gd_resource type="ShaderMaterial" load_steps=8 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode unshaded;

const float DISPLACEMENT = 0.005;

const float displacement_gain = 3.0;

uniform float color_solid_size               = 1.6;
uniform float color_attenuation_size         = 1.5;
uniform float exhaust_speed            = 30.0;
uniform float texture_scale_horizontal = 0.5;
uniform float texture_scale_vertical   = 0.1;
uniform sampler2D noise;
uniform sampler2D displacement_x;
uniform sampler2D displacement_z;

uniform vec4 color_bright: hint_color = vec4( 0.6471, 0.6039, 0.0, 1.0 );
uniform vec4 color_dark:   hint_color = vec4( 0.0, 0.0, 0.0, 1.0 );
uniform float dark_ratio = 0.4;

varying float time;
varying vec3 point3d;
varying vec3 normal3d;





vec4 compute_color( sampler2D tex, float t, vec3 r, vec3 n )
{
	float y = r.y + exhaust_speed * t;
	vec2 uv = vec2( r.x*texture_scale_horizontal, y*texture_scale_vertical );
	float c_xy = texture( tex, uv ).x;
	uv = vec2( r.x*texture_scale_horizontal, r.z*texture_scale_horizontal );
	float c_xz = texture( tex, uv ).x;
	uv = vec2( y*texture_scale_vertical, r.z*texture_scale_horizontal );
	float c_yz = texture( tex, uv ).x;
	vec3 an = abs(n);
	float c = c_xy*an.z + c_xz*an.y + c_yz*an.x;
	c = 0.6 - c;
	float alpha = (c < 0.0) ? 0.0 : 1.0;
	alpha *= clamp( color_solid_size + r.y/color_attenuation_size, 0.0, 1.0 );
	
	float coef = clamp(c*10.0, 0.0, 1.0 );
	
	vec4 color;
	color.a   = alpha;
	color.rgb = color_bright.rgb * (1.0-coef) + color_dark.rgb * (coef);
	
	return color;
}

vec2 compute_displacement( float t, vec3 r, vec3 n )
{
	float gain = abs(r.y/displacement_gain) * DISPLACEMENT;
	float y = r.y + exhaust_speed * t;
	y = mod( y/displacement_gain, 1.0 );

	vec2 uv = vec2( r.x, y );
	float dx = texture( displacement_x, uv ).r - 0.5;

	uv = vec2( r.z, y );
	float dz = texture( displacement_z, uv ).r - 0.5;
	
	dx *= gain;
	dz *= gain;
	return vec2( dx, dz );
}



void vertex()
{
	time     = TIME;
	point3d  = VERTEX;
	normal3d = NORMAL;
	
//	vec2 d = compute_displacement( time, point3d, normal3d );
//	float x = VERTEX.x + d.x;
//	float z = VERTEX.z + d.y;
//	VERTEX.x = x;
//	VERTEX.z = z;
}

void fragment()
{
	vec4 color;
	color = compute_color( noise, time, point3d, normal3d );
	ALBEDO = color.rgb;
	ALPHA  = color.a;
}
"

[sub_resource type="OpenSimplexNoise" id=2]
seed = 1
period = 15.0

[sub_resource type="NoiseTexture" id=3]
width = 128
height = 128
seamless = true
noise = SubResource( 2 )

[sub_resource type="OpenSimplexNoise" id=4]
seed = 2
period = 15.0

[sub_resource type="NoiseTexture" id=5]
width = 128
height = 128
seamless = true
noise = SubResource( 4 )

[sub_resource type="OpenSimplexNoise" id=6]
period = 15.0

[sub_resource type="NoiseTexture" id=7]
width = 128
height = 128
seamless = true
noise = SubResource( 6 )

[resource]
shader = SubResource( 1 )
shader_param/color_solid_size = 1.6
shader_param/color_attenuation_size = 1.5
shader_param/exhaust_speed = 30.0
shader_param/texture_scale_horizontal = 0.5
shader_param/texture_scale_vertical = 0.1
shader_param/color_bright = Color( 0.6471, 0.8039, 0, 1 )
shader_param/color_dark = Color( 0.1, 0.1, 0.1, 1 )
shader_param/dark_ratio = 0.4
shader_param/noise = SubResource( 7 )
shader_param/displacement_x = SubResource( 3 )
shader_param/displacement_z = SubResource( 5 )
