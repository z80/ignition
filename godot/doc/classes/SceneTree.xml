<?xml version="1.0" encoding="UTF-8" ?>
<class name="SceneTree" inherits="MainLoop" category="Core" version="3.1.2">
	<brief_description>
		Manages the game loop via a hierarchy of nodes.
	</brief_description>
	<description>
		As one of the most important classes, the [code]SceneTree[/code] manages the hierarchy of nodes in a scene as well as scenes themselves. Nodes can be added, retrieved and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded.
		You can also use the [code]SceneTree[/code] to organize your nodes into groups: every node can be assigned as many groups as you want to create, e.g. a "enemy" group. You can then iterate these groups or even call methods and set properties on all the group's members at once.
		[code]SceneTree[/code] is the default [MainLoop] implementation used by scenes, and is thus in charge of the game loop.
	</description>
	<tutorials>
		<link>https://docs.godotengine.org/en/3.1/getting_started/step_by_step/scene_tree.html</link>
		<link>https://docs.godotengine.org/en/3.1/tutorials/viewports/multiple_resolutions.html</link>
	</tutorials>
	<methods>
		<method name="call_group" qualifiers="vararg">
			<return type="Variant">
			</return>
			<argument index="0" name="group" type="String">
			</argument>
			<argument index="1" name="method" type="String">
			</argument>
			<description>
				Calls [code]method[/code] on each member of the given group.
			</description>
		</method>
		<method name="call_group_flags" qualifiers="vararg">
			<return type="Variant">
			</return>
			<argument index="0" name="flags" type="int">
			</argument>
			<argument index="1" name="group" type="String">
			</argument>
			<argument index="2" name="method" type="String">
			</argument>
			<description>
				Calls [code]method[/code] on each member of the given group, respecting the given [enum GroupCallFlags].
			</description>
		</method>
		<method name="change_scene">
			<return type="int" enum="Error">
			</return>
			<argument index="0" name="path" type="String">
			</argument>
			<description>
				Changes the running scene to the one at the given [code]path[/code], after loading it into a [PackedScene] and creating a new instance.
				Returns [constant @GlobalScope.OK] on success, [constant @GlobalScope.ERR_CANT_OPEN] if the [code]path[/code] cannot be loaded into a [PackedScene], or [constant @GlobalScope.ERR_CANT_CREATE] if that scene cannot be instantiated.
			</description>
		</method>
		<method name="change_scene_to">
			<return type="int" enum="Error">
			</return>
			<argument index="0" name="packed_scene" type="PackedScene">
			</argument>
			<description>
				Changes the running scene to a new instance of the given [PackedScene].
				Returns [constant @GlobalScope.OK] on success or [constant @GlobalScope.ERR_CANT_CREATE] if the scene cannot be instantiated.
			</description>
		</method>
		<method name="create_timer">
			<return type="SceneTreeTimer">
			</return>
			<argument index="0" name="time_sec" type="float">
			</argument>
			<argument index="1" name="pause_mode_process" type="bool" default="true">
			</argument>
			<description>
				Returns a [SceneTreeTimer] which will [signal SceneTreeTimer.timeout] after the given time in seconds elapsed in this [code]SceneTree[/code]. If [code]pause_mode_process[/code] is set to [code]false[/code], pausing the [code]SceneTree[/code] will also pause the timer.
				Commonly used to create a one-shot delay timer as in the following example:
				[codeblock]
				func some_function():
					print("start")
					yield(get_tree().create_timer(1.0), "timeout")
					print("end")
				[/codeblock]
			</description>
		</method>
		<method name="get_frame" qualifiers="const">
			<return type="int">
			</return>
			<description>
				Returns the current frame number, i.e. the total frame count since the application started.
			</description>
		</method>
		<method name="get_network_connected_peers" qualifiers="const">
			<return type="PoolIntArray">
			</return>
			<description>
				Returns the peer IDs of all connected peers of this [code]SceneTree[/code]'s [member network_peer].
			</description>
		</method>
		<method name="get_network_unique_id" qualifiers="const">
			<return type="int">
			</return>
			<description>
				Returns the unique peer ID of this [code]SceneTree[/code]'s [member network_peer].
			</description>
		</method>
		<method name="get_node_count" qualifiers="const">
			<return type="int">
			</return>
			<description>
				Returns the number of nodes in this [code]SceneTree[/code].
			</description>
		</method>
		<method name="get_nodes_in_group">
			<return type="Array">
			</return>
			<argument index="0" name="group" type="String">
			</argument>
			<description>
				Returns a list of all nodes assigned to the given group.
			</description>
		</method>
		<method name="get_rpc_sender_id" qualifiers="const">
			<return type="int">
			</return>
			<description>
				Returns the sender's peer ID for the most recently received RPC call.
			</description>
		</method>
		<method name="has_group" qualifiers="const">
			<return type="bool">
			</return>
			<argument index="0" name="name" type="String">
			</argument>
			<description>
				Returns [code]true[/code] if the given group exists.
			</description>
		</method>
		<method name="has_network_peer" qualifiers="const">
			<return type="bool">
			</return>
			<description>
				Returns [code]true[/code] if there is a [member network_peer] set.
			</description>
		</method>
		<method name="is_input_handled">
			<return type="bool">
			</return>
			<description>
				Returns [code]true[/code] if the most recent [InputEvent] was marked as handled with [method set_input_as_handled].
			</description>
		</method>
		<method name="is_network_server" qualifiers="const">
			<return type="bool">
			</return>
			<description>
				Returns [code]true[/code] if this [code]SceneTree[/code]'s [member network_peer] is in server mode (listening for connections).
			</description>
		</method>
		<method name="notify_group">
			<return type="void">
			</return>
			<argument index="0" name="group" type="String">
			</argument>
			<argument index="1" name="notification" type="int">
			</argument>
			<description>
				Sends the given notification to all members of the [code]group[/code].
			</description>
		</method>
		<method name="notify_group_flags">
			<return type="void">
			</return>
			<argument index="0" name="call_flags" type="int">
			</argument>
			<argument index="1" name="group" type="String">
			</argument>
			<argument index="2" name="notification" type="int">
			</argument>
			<description>
				Sends the given notification to all members of the [code]group[/code], respecting the given [enum GroupCallFlags].
			</description>
		</method>
		<method name="queue_delete">
			<return type="void">
			</return>
			<argument index="0" name="obj" type="Object">
			</argument>
			<description>
				Queues the given object for deletion, delaying the call to [method Object.free] to after the current frame.
			</description>
		</method>
		<method name="quit">
			<return type="void">
			</return>
			<description>
				Quits the application.
			</description>
		</method>
		<method name="reload_current_scene">
			<return type="int" enum="Error">
			</return>
			<description>
				Reloads the currently active scene.
				Returns an [enum @GlobalScope.Error] code as described in [method change_scene], with the addition of [constant @GlobalScope.ERR_UNCONFIGURED] if no [member current_scene] was defined yet.
			</description>
		</method>
		<method name="set_auto_accept_quit">
			<return type="void">
			</return>
			<argument index="0" name="enabled" type="bool">
			</argument>
			<description>
				If [code]true[/code], the application automatically accepts quitting. Defaults to [code]true[/code].
			</description>
		</method>
		<method name="set_group">
			<return type="void">
			</return>
			<argument index="0" name="group" type="String">
			</argument>
			<argument index="1" name="property" type="String">
			</argument>
			<argument index="2" name="value" type="Variant">
			</argument>
			<description>
				Sets the given [code]property[/code] to [code]value[/code] on all members of the given group.
			</description>
		</method>
		<method name="set_group_flags">
			<return type="void">
			</return>
			<argument index="0" name="call_flags" type="int">
			</argument>
			<argument index="1" name="group" type="String">
			</argument>
			<argument index="2" name="property" type="String">
			</argument>
			<argument index="3" name="value" type="Variant">
			</argument>
			<description>
				Sets the given [code]property[/code] to [code]value[/code] on all members of the given group, respecting the given [enum GroupCallFlags].
			</description>
		</method>
		<method name="set_input_as_handled">
			<return type="void">
			</return>
			<description>
				Marks the most recent [InputEvent] as handled.
			</description>
		</method>
		<method name="set_quit_on_go_back">
			<return type="void">
			</return>
			<argument index="0" name="enabled" type="bool">
			</argument>
			<description>
				If [code]true[/code], the application quits automatically on going back (e.g. on Android). Defaults to [code]true[/code].
			</description>
		</method>
		<method name="set_screen_stretch">
			<return type="void">
			</return>
			<argument index="0" name="mode" type="int" enum="SceneTree.StretchMode">
			</argument>
			<argument index="1" name="aspect" type="int" enum="SceneTree.StretchAspect">
			</argument>
			<argument index="2" name="minsize" type="Vector2">
			</argument>
			<argument index="3" name="shrink" type="float" default="1">
			</argument>
			<description>
				Configures screen stretching to the given [enum StretchMode], [enum StretchAspect], minimum size and [code]shrink[/code] ratio.
			</description>
		</method>
	</methods>
	<members>
		<member name="current_scene" type="Node" setter="set_current_scene" getter="get_current_scene">
			The current scene.
		</member>
		<member name="debug_collisions_hint" type="bool" setter="set_debug_collisions_hint" getter="is_debugging_collisions_hint">
			If [code]true[/code], collision shapes will be visible when running the game from the editor for debugging purposes.
		</member>
		<member name="debug_navigation_hint" type="bool" setter="set_debug_navigation_hint" getter="is_debugging_navigation_hint">
			If [code]true[/code], navigation polygons will be visible when running the game from the editor for debugging purposes.
		</member>
		<member name="edited_scene_root" type="Node" setter="set_edited_scene_root" getter="get_edited_scene_root">
			The root of the edited scene.
		</member>
		<member name="multiplayer" type="MultiplayerAPI" setter="set_multiplayer" getter="get_multiplayer">
			The default [MultiplayerAPI] instance for this [code]SceneTree[/code].
		</member>
		<member name="multiplayer_poll" type="bool" setter="set_multiplayer_poll_enabled" getter="is_multiplayer_poll_enabled">
			If [code]true[/code] (default value), enable the automatic polling of the [MultiplayerAPI] for this [code]SceneTree[/code] during [signal idle_frame].
			When [code]false[/code] you need to manually call [method MultiplayerAPI.poll] for processing network packets and delivering RPCs/RSETs. This allows to run RPCs/RSETs in a different loop (e.g. physics, thread, specific time step) and for manual [Mutex] protection when accessing the [MultiplayerAPI] from threads.
		</member>
		<member name="network_peer" type="NetworkedMultiplayerPeer" setter="set_network_peer" getter="get_network_peer">
			The peer object to handle the RPC system (effectively enabling networking when set). Depending on the peer itself, the [code]SceneTree[/code] will become a network server (check with [method is_network_server]) and will set root node's network mode to master (see NETWORK_MODE_* constants in [Node]), or it will become a regular peer with root node set to puppet. All child nodes are set to inherit the network mode by default. Handling of networking-related events (connection, disconnection, new clients) is done by connecting to [code]SceneTree[/code]'s signals.
		</member>
		<member name="paused" type="bool" setter="set_pause" getter="is_paused">
			If [code]true[/code], the [code]SceneTree[/code] is paused. Doing so will have the following behavior:
			- 2D and 3D physics will be stopped.
			- [method Node._process], [method Node._physics_process] and [method Node._input] will not be called anymore in nodes.
		</member>
		<member name="refuse_new_network_connections" type="bool" setter="set_refuse_new_network_connections" getter="is_refusing_new_network_connections">
			If [code]true[/code], the [code]SceneTree[/code]'s [member network_peer] refuses new incoming connections.
		</member>
		<member name="root" type="Viewport" setter="" getter="get_root">
			The [code]SceneTree[/code]'s root [Viewport].
		</member>
		<member name="use_font_oversampling" type="bool" setter="set_use_font_oversampling" getter="is_using_font_oversampling">
			If [code]true[/code], font oversampling is used.
		</member>
	</members>
	<signals>
		<signal name="connected_to_server">
			<description>
				Emitted whenever this [code]SceneTree[/code]'s [member network_peer] successfully connected to a server. Only emitted on clients.
			</description>
		</signal>
		<signal name="connection_failed">
			<description>
				Emitted whenever this [code]SceneTree[/code]'s [member network_peer] fails to establish a connection to a server. Only emitted on clients.
			</description>
		</signal>
		<signal name="files_dropped">
			<argument index="0" name="files" type="PoolStringArray">
			</argument>
			<argument index="1" name="screen" type="int">
			</argument>
			<description>
				Emitted when files are dragged from the OS file manager and dropped in the game window. The arguments are a list of file paths and the identifier of the screen where the drag originated.
			</description>
		</signal>
		<signal name="idle_frame">
			<description>
				Emitted immediately before [method Node._process] is called on every node in the [code]SceneTree[/code].
			</description>
		</signal>
		<signal name="network_peer_connected">
			<argument index="0" name="id" type="int">
			</argument>
			<description>
				Emitted whenever this [code]SceneTree[/code]'s [member network_peer] connects with a new peer. ID is the peer ID of the new peer. Clients get notified when other clients connect to the same server. Upon connecting to a server, a client also receives this signal for the server (with ID being 1).
			</description>
		</signal>
		<signal name="network_peer_disconnected">
			<argument index="0" name="id" type="int">
			</argument>
			<description>
				Emitted whenever this [code]SceneTree[/code]'s [member network_peer] disconnects from a peer. Clients get notified when other clients disconnect from the same server.
			</description>
		</signal>
		<signal name="node_added">
			<argument index="0" name="node" type="Node">
			</argument>
			<description>
				Emitted whenever a node is added to the [code]SceneTree[/code].
			</description>
		</signal>
		<signal name="node_configuration_warning_changed">
			<argument index="0" name="node" type="Node">
			</argument>
			<description>
				Emitted when a node's configuration changed. Only emitted in tool mode.
			</description>
		</signal>
		<signal name="node_removed">
			<argument index="0" name="node" type="Node">
			</argument>
			<description>
				Emitted whenever a node is removed from the [code]SceneTree[/code].
			</description>
		</signal>
		<signal name="physics_frame">
			<description>
				Emitted immediately before [method Node._physics_process] is called on every node in the [code]SceneTree[/code].
			</description>
		</signal>
		<signal name="screen_resized">
			<description>
				Emitted whenever the screen resolution (fullscreen) or window size (windowed) changes.
			</description>
		</signal>
		<signal name="server_disconnected">
			<description>
				Emitted whenever this [code]SceneTree[/code]'s [member network_peer] disconnected from server. Only emitted on clients.
			</description>
		</signal>
		<signal name="tree_changed">
			<description>
				Emitted whenever the [code]SceneTree[/code] hierarchy changed (children being moved or renamed, etc.).
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="GROUP_CALL_DEFAULT" value="0" enum="GroupCallFlags">
			Call a group with no flags (default).
		</constant>
		<constant name="GROUP_CALL_REVERSE" value="1" enum="GroupCallFlags">
			Call a group in reverse scene order.
		</constant>
		<constant name="GROUP_CALL_REALTIME" value="2" enum="GroupCallFlags">
			Call a group immediately (calls are normally made on idle).
		</constant>
		<constant name="GROUP_CALL_UNIQUE" value="4" enum="GroupCallFlags">
			Call a group only once even if the call is executed many times.
		</constant>
		<constant name="STRETCH_MODE_DISABLED" value="0" enum="StretchMode">
			No stretching.
		</constant>
		<constant name="STRETCH_MODE_2D" value="1" enum="StretchMode">
			Render stretching in higher resolution (interpolated).
		</constant>
		<constant name="STRETCH_MODE_VIEWPORT" value="2" enum="StretchMode">
			Keep the specified display resolution. No interpolation. Content may appear pixelated.
		</constant>
		<constant name="STRETCH_ASPECT_IGNORE" value="0" enum="StretchAspect">
			Fill the window with the content stretched to cover excessive space. Content may appear elongated.
		</constant>
		<constant name="STRETCH_ASPECT_KEEP" value="1" enum="StretchAspect">
			Retain the same aspect ratio by padding with black bars in either axes. No expansion of content.
		</constant>
		<constant name="STRETCH_ASPECT_KEEP_WIDTH" value="2" enum="StretchAspect">
			Expand vertically. Left/right black bars may appear if the window is too wide.
		</constant>
		<constant name="STRETCH_ASPECT_KEEP_HEIGHT" value="3" enum="StretchAspect">
			Expand horizontally. Top/bottom black bars may appear if the window is too tall.
		</constant>
		<constant name="STRETCH_ASPECT_EXPAND" value="4" enum="StretchAspect">
			Expand in both directions, retaining the same aspect ratio. No black bars.
		</constant>
	</constants>
</class>
