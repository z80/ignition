#!/usr/bin/env python

import sys

Import('env')

# The main source files of our Slicer plugin. We could also
# do a Glob to get cpp files automatically but for now we'll
# use an opt-in process just to have better control over what goes
# into the final binary during development. (Especially because we
# have some test files mucking things up)
sources        = "src/*.cpp"
native_sources = "src/gdnative/*.cpp"

# Linking the final Godot binaries can take a bit of time. Following advice
# from https://docs.godotengine.org/en/stable/development/cpp/custom_modules_in_cpp.html
# we instead put our main logic into a shared library (as this is more likely to require tweaking).
# This allows us to build the main binaries once and link them against quick to build artifacts dynamically
use_shared_libs = ARGUMENTS.get('slicer_shared', 'no') == 'yes'

module_env = env.Clone()
module_env.Append(CXXFLAGS=['-std=c++11'])


# Build the plugin statically for more reliable builds
def configure_static_build():
    #module_env.Append(CCFLAGS=['-O2'])
    env.Append(CPPPATH=["src"])
    module_env.Append(CPPPATH=["#modules/ignition/src"])
    module_env.Append(CPPPATH=["#modules/gdnative/include"])
    module_env.add_source_files( env.modules_sources, sources )
    module_env.add_source_files( env.modules_sources, native_sources )
    # To also add "register_types.h"
    module_env.add_source_files(env.modules_sources, "*.cpp")

    from platform_methods import run_in_subprocess
    import gdnative_builders

    _, gensource = module_env.CommandNoCache(['gdnative_api_struct.gen.h', 'gdnative_api_struct.gen.cpp'],
                                              'gdnative_api.json', run_in_subprocess(gdnative_builders.build_gdnative_api_struct))
    module_env.add_source_files(env.modules_sources, [gensource])



configure_static_build()

#if ARGUMENTS.get('slicer_tests', 'no') == 'yes':
#    SConscript("tests/SCsub")
