[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode unshaded;

// Atmosphere parameters
uniform vec4  atmosphere_color_day:     hint_color = vec4( 0.3, 0.3, 0.7, 1.0 );
uniform vec4  atmosphere_color_evening: hint_color = vec4( 0.7, 0.3, 0.3, 1.0 );
uniform vec3  sphere_position = vec3(0.0, 0.0, 0.0);
uniform float sphere_radius = 50.0;
uniform float atmosphere_height    = 2.0;
uniform float opaque_height        = 1.0;
uniform float transparency_distance_outer = 30.0;
uniform float transparency_distance_inner = 0.5;
uniform vec3  light_dir     = vec3(1.0, 0.0, 0.0);
uniform float displacement: hint_range(-5.0, 5.0);

varying vec3 cam_position;

bool ray_atmosphere_intersection_length( vec3 ray_origin, vec3 sphere_center, vec3 ray, out float len, out bool inside, out float day_evening )
{
	vec3 sphere_rel = sphere_center - ray_origin;
	// Find the closest point.
	float t = dot( sphere_rel, ray );
	vec3 v = ray*t - sphere_rel;
	// Distance from the closest point to the sphere center should be 
	// smaller than radius.
	float d = length(v);
	// Atmosphere radius.
	float R = sphere_radius + atmosphere_height;
	if ( d > R )
	{
		len    = 0.0;
		inside = false;
		return false;
	}
	
	// Compute using Phifagorous theorem.
	float x = sqrt( R*R - d*d );
	float t2 = t + x;
	float t1_candidate = t - x;
	inside = ( t1_candidate < 0.0 );
	float t1;
	if (inside)
		t1 = 0.0;
	else
		t1 = t1_candidate;

	// Intersects surface?
	//bool intersects_surface = (d < sphere_radius);
	// If intersects surface, need to crop the distance 
	// to the surface intersection.
	x = sqrt( sphere_radius*sphere_radius - d*d );
	float surf_t1 = t - x;
	// If surface is on the way.
	/*if ( surf_t1 > 0.0 )
	{
		// If inside atmosphere, make it transparent, i.e. no distance fog.
		// No, make it totally opaque.
		if ( !inside )
			// Should make it fully transparent outside.
			t2 = t1; //surf_t1;
	}*/
	
	len = t2 - t1;
	
	// Additional reduction of effective length depending on how high ray goes.
	float opaque_r = sphere_radius + opaque_height;
	if ( d > opaque_r )
	{
		float height = (d - opaque_r)/(atmosphere_height - opaque_height);
		len *= (1.0 - height);
	}
	
	// Also redusing by means of sun light direction.
	v = ray; //ray*t1 + ray_origin;
	vec3 at = v / length( v );
	d = clamp( dot( at,light_dir ) + displacement, 0.0, 1.0 );
	day_evening = d;
	len *= d;
	
	return true;
}

float ramp_transparency_length( vec3 ray_origin, vec3 sphere_center )
{
	float distance_from_center = length(ray_origin - sphere_center);
	float outer_radius = sphere_radius + atmosphere_height;
	float opaque_radius = sphere_radius + opaque_height;
	if (distance_from_center < opaque_radius)
		return transparency_distance_inner;
	else if ( distance_from_center > outer_radius )
		return transparency_distance_outer;
	
	float alpha = (distance_from_center - opaque_radius) / (outer_radius - opaque_radius);
	float t = transparency_distance_outer * alpha + transparency_distance_inner * (1.0 - alpha);
	
	return t;
}

vec4 compute_atmosphere_color( vec3 ray_origin, vec3 sphere_center, vec3 ray )
{
	float through_length;
	bool  inside;
	float dot_;
	bool intersects = ray_atmosphere_intersection_length( ray_origin, sphere_center, ray, through_length, inside, dot_ );
	if ( !intersects )
	{
		vec4 c = vec4( atmosphere_color_day.xyz, 0.0 );
		return c;
	}
	
//	if (inside)
//	{
//		//vec4 c = vec4( 0.0, 0.7, 0.0, 1.0 );
//		//return c;
//		//through_length = sphere_radius + 1.0;
//	}
	
	float transparency_scale = ramp_transparency_length( ray_origin, sphere_center );
	float alpha = clamp( through_length / transparency_scale, 0.0, 1.0 );
	if (inside)
	{
		alpha = 1.0;
	}
	
	float k_day = dot_;
	float k_evening = 1.0 - dot_;
	vec4 color = atmosphere_color_day*k_day  + atmosphere_color_evening*k_evening;
	vec4 c = vec4( color.xyz, alpha );
	return c;
}


void vertex()
{
	//sphere_position = (WORLD_MATRIX * vec4(0.0, 0.0, 0.0, 1.0) ).xyz;
	cam_position = (CAMERA_MATRIX * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
}

void fragment()
{
	vec3 ray = -(CAMERA_MATRIX * vec4(VIEW, 0.0)).xyz;
	ray = ray / length(ray);
	
	//bool ok = ray_intersects_sphere( cam_position, sphere_position, ray, sphere_radius );
	
	//float len = 0.0;
	//bool inside = false;
	//bool ok2 = ray_sphere_intersection_length( cam_position, sphere_position, ray, sphere_radius, len, inside );
	
	//bool ok3 = ray_atmosphere_intersection_length( cam_position, sphere_position, ray, sphere_radius, atmosphere_height, len, inside );
	
	//ALBEDO.r = len / sphere_radius/2.0;
	//ALBEDO.g = 0.0;
	//ALBEDO.b = 0.0;
	//ALPHA = len / sphere_radius/2.0;
	
	vec4 c = compute_atmosphere_color( cam_position, sphere_position, ray );
	ALBEDO = c.rgb;
	ALPHA  = c.a;
}
"

[resource]
shader = SubResource( 1 )
shader_param/atmosphere_color_day = Color( 0.470588, 0.560784, 0.611765, 1 )
shader_param/atmosphere_color_evening = Color( 0.607843, 0.227451, 0.227451, 1 )
shader_param/sphere_position = Vector3( 0, 0, 0 )
shader_param/sphere_radius = 8.0
shader_param/atmosphere_height = 4.0
shader_param/opaque_height = 1.0
shader_param/transparency_distance_outer = 30.0
shader_param/transparency_distance_inner = 0.5
shader_param/light_dir = Vector3( 1, 0, 0 )
shader_param/displacement = 1.0
