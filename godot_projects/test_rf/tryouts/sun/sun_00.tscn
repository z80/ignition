[gd_scene load_steps=16 format=2]

[sub_resource type="SphereMesh" id=1]

[sub_resource type="SpatialMaterial" id=2]
flags_unshaded = true
albedo_color = Color( 1, 0.964706, 0.72549, 1 )

[sub_resource type="SphereMesh" id=3]

[sub_resource type="OpenSimplexNoise" id=4]
period = 13.1

[sub_resource type="NoiseTexture" id=5]
seamless = true
noise = SubResource( 4 )

[sub_resource type="VisualShaderNodeTexture" id=6]
output_port_for_preview = 0
texture = SubResource( 5 )
texture_type = 1

[sub_resource type="VisualShaderNodeColorConstant" id=7]
output_port_for_preview = 0
constant = Color( 1, 0.844748, 0, 1 )

[sub_resource type="VisualShaderNodeColorOp" id=8]
operator = 2

[sub_resource type="VisualShader" id=9]
code = "shader_type spatial;
render_mode specular_schlick_ggx;

uniform sampler2D tex_frg_2 : hint_albedo;



void vertex() {
// Output:0

}

void fragment() {
// Texture:2
	vec4 tex_frg_2_read = texture(tex_frg_2, UV.xy);
	vec3 n_out2p0 = tex_frg_2_read.rgb;
	float n_out2p1 = tex_frg_2_read.a;

// Color:6
	vec3 n_out6p0 = vec3(1.000000, 0.844748, 0.000000);
	float n_out6p1 = 1.000000;

// ColorOp:7
	vec3 n_out7p0 = min(n_out2p0, n_out6p0);

// Output:0
	ALBEDO = n_out7p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( 38, 51.7926 )
nodes/fragment/0/position = Vector2( 760, 60 )
nodes/fragment/2/node = SubResource( 6 )
nodes/fragment/2/position = Vector2( 40, 140 )
nodes/fragment/6/node = SubResource( 7 )
nodes/fragment/6/position = Vector2( 80, 500 )
nodes/fragment/7/node = SubResource( 8 )
nodes/fragment/7/position = Vector2( 440, 280 )
nodes/fragment/connections = PoolIntArray( 6, 0, 7, 1, 7, 0, 0, 0, 2, 0, 7, 0 )

[sub_resource type="ShaderMaterial" id=10]
shader = SubResource( 9 )

[sub_resource type="Shader" id=11]
code = "shader_type spatial;
render_mode unshaded;

// Atmosphere parameters
uniform vec4  light_color: hint_color = vec4( 1.0, 0.988, 0.871, 1.0 );
uniform vec3  light_dir     = vec3(1.0, -0.5, 0.0);
uniform float light_size    = 0.05;
uniform float glow_size     = 0.1;
uniform float ray_scale     = 6.0;
uniform float ray_size      = 0.5;
uniform float ray_bias      = 0.3;

// Noise for rays generation.
uniform sampler2D noise;



vec4 sun_color( in vec3 ray_local, in vec3 light_dir_local )
{
	// First check if it is the same direction to reject sun behind.
	if (light_dir_local.z < 0.0)
		return vec4( light_color.xyz, 0.0 );
	float dist = length( ray_local.xy - light_dir_local.xy );
	float light_and_glow = light_size + glow_size;
	if (dist > light_and_glow)
		return vec4( light_color.xyz, 0.0 );
	if ( dist <= light_size )
		return light_color;
	
	// Ramp transparency.
	// (x-1)/(deviation_sine-light_size) = (0-1)/(light_and_glow - light_size)
	// x = 1 - (deviation_sine-light_size)/(light_and_glow-light_size)
	float alpha = pow(1.0 - (dist-light_size)/(light_and_glow-light_size), 5.0 );
	
	//alpha *= 0.0;
	return vec4(light_color.xyz, alpha);
}

vec4 rays_color( in vec3 view_local, in vec3 light_dir_local )
{
	if (light_dir_local.z < 0.0)
		return vec4( light_color.xyz, 0.0 );

	// Draw center.
	/*{
		float view_to_center_len = length(view_local.xy);
		if ( view_to_center_len < 0.02 )
			return vec4( 0.0, 0.5, 0.0, 1.0);
	}
	// Draw line to screen center.
	{
		vec2 light = light_dir_local.xy;
		vec2 view  = view_local.xy;
		float light_len = length( light );
		if ( light_len < 0.001 )
			return vec4( 0.0 );
		float dist = abs(light.x*view.y - light.y*view.x);
		if ( dist < 0.002 )
			return light_color;
	}*/
	
	vec2 view_rel = view_local.xy - light_dir_local.xy;
	float view_len = length( view_rel );
	if ( view_len < 0.001 )
		return vec4( 0.0 );
	view_rel = view_rel * (light_size / view_len);
	vec2 sun_edge = light_dir_local.xy + view_rel;
	// Distance of this sun edge to the center of screen.
	float sun_edge_len = length( sun_edge );
	
	
	
	vec2  edge_to_view = view_local.xy - sun_edge;
	float edge_to_view_len = length(edge_to_view);
	float arg = atan( view_rel.y, view_rel.x );
	float ray_length = ray_size * ( 1.0 - clamp( sun_edge_len/(light_size*ray_scale) - ray_bias, 0.0, 1.0 ) );
	float alpha;
	if ( view_len < light_size )
		alpha = 1.0;
	else
		alpha = pow( clamp( 1.0 - edge_to_view_len / ray_length, 0.0, 1.0 ), 5.0 );
	float t = texture( noise, vec2( arg, 0.5 ) ).r;
	float tex_th = 0.0;
	t = clamp( t-tex_th, 0.0, 1.0 )  * (1.0 - tex_th);
	alpha = alpha * pow(t, 5.0);
	return vec4( light_color.xyz, alpha );
}


void vertex()
{
}

void fragment()
{
	vec3 ray = -(CAMERA_MATRIX * vec4(VIEW, 0.0)).xyz;
	ray = ray / length(ray);
	
	vec3 sun_dir_local = -(INV_CAMERA_MATRIX * vec4(light_dir, 0.0)).xyz;
	
	vec4 c = sun_color( VIEW, sun_dir_local );
	vec4 rc = rays_color( VIEW, sun_dir_local );
	//if ( c.a < rc.a )
	c.rgb = mix( c.rgb, rc.rgb, rc.a );
	c.a = max(c.a, rc.a);
	ALBEDO = c.rgb;
	ALPHA  = c.a;
}
"

[sub_resource type="OpenSimplexNoise" id=14]
octaves = 1
period = 5.0

[sub_resource type="NoiseTexture" id=15]
width = 128
height = 128
seamless = true
noise = SubResource( 14 )

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )
shader_param/light_color = Color( 1, 0.988, 0.871, 1 )
shader_param/light_dir = Vector3( 1, -0.5, 0 )
shader_param/light_size = 0.05
shader_param/glow_size = 0.1
shader_param/ray_scale = 6.0
shader_param/ray_size = 0.5
shader_param/ray_bias = 0.3
shader_param/noise = SubResource( 15 )

[sub_resource type="CubeMesh" id=13]
flip_faces = true
size = Vector3( 100, 100, 100 )

[node name="Spatial" type="Spatial"]

[node name="MeshInstance" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -11.0783, 7.45979, 0 )
visible = false
mesh = SubResource( 1 )
material/0 = SubResource( 2 )

[node name="MeshInstance_2" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1.94433 )
visible = false
mesh = SubResource( 3 )
material/0 = SubResource( 10 )

[node name="MeshInstance_3" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 5.50625, 8.49195, 8.84745 )
material_override = SubResource( 12 )
mesh = SubResource( 13 )
material/0 = null
